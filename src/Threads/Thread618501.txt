#include "Thread61850.h"
#include <stdio.h>
#include <sys/time.h>
#include <unistd.h>
#include <sys/mman.h>
#include <string.h>
#include <signal.h>
#include <semaphore.h>
#include <stdlib.h>
#include <bits/types.h>
#include <sys/shm.h>
#include <fcntl.h>
#include "sys.h"
#include "IEC61850_type.h"
#include "WritePCS.h"

int cur_posEmu = 0;

PARA_61850 Frome61850;
PARA_61850 *pFrome61850=(PARA_61850 *)&Frome61850; 
iec61850_shm_packet_t *iec61850_shm = NULL;
// int g_shmid = -1;
// void killexit(int signo)
// {
// 	shmdt(pFrom61850);
// 	shmctl(g_shmid, IPC_RMID, 0);
// 	printf("  程序终止  ！！\n");
// 	exit(1);
// }
#if 0
void xxxx0()
{
	//通信程序负责创建共享内存和信号量，示例代码如下：
	key_t key = ftok(IEC61850_IPC_PATH, IEC61850_IPC_KEY);
    int id = shmget(key,sizeof(iec61850_shm_packet_t),IPC_CREAT|0666);
    sem_t  *SHM_SEM1;
    SHM_SEM1 = sem_open(SHM_SEM1_PATH,O_CREAT,0644,0);
    sem_t  * SHM_SEM2;
    SHM_SEM 2= sem_open(SHM_SEM2_PATH,O_CREAT,0644,0);
   sem_t  * SHM_MUTEX1;
    SHM_MUTEX1 = sem_open(SHM_MUTEX1_PATH,O_CREAT,0644,1);
    sem_t  * SHM_MUTEX2;
    SHM_MUTEX2 = sem_open(SHM_MUTEX2_PATH,O_CREAT,0644,1);

}

void xxxx1()
{
//通信程序写数据区的示例代码如下：	
sem_wait (SHM_SEM1);
sem_wait(SHM_MUTEX1);
//在此区间读取命令
sem_post(SHM_MUTEX1);


}

void xxxx2()
{

//通信程序读命令区的示例代码如下：
sem_wait (SHM_SEM2);
sem_wait(SHM_MUTEX2);
//在此区间读取命令
sem_post(SHM_MUTEX2);


}
#endif
sem_t *SHM_SEM1;
sem_t *SHM_SEM2;
sem_t *SHM_MUTEX1;
sem_t *SHM_MUTEX2;
// void ReadDataFrom61850()
// {
// 	int i = 0;
// 	data_info_t temp;
// 	if (cur_pos61850 == iec61850_shm->shm_que2.wpos)
// 		return;
// 	//协调控制程序读数据区的示例代码如下：

// 	sem_wait(SHM_SEM1);
// 	sem_wait(SHM_MUTEX1);
// 	//在此区间读取命令

// 	for (i = 0; i < iec61850_shm->shm_que2.wpos - cur_pos61850; i++)
// 	{
// 		temp = iec61850_shm->shm_que2.slist[i + cur_pos61850];
// 	}
// 	cur_pos61850 += iec61850_shm->shm_que2.wpos - cur_pos61850;
// 	sem_post(SHM_MUTEX1);
// }
void ReadDataFrom61850()
{
	int i = 0;
	data_info_t temp;
	int i = 0;
	if (shm_addr->shm_que2.rpos == shm_addr->shm_que2.wpos)
		return;
	//协调控制程序读数据区的示例代码如下：

    cur_pos61850 = shm_addr->shm_que2.rpos;

	for (i = 0; i < iec61850_shm->shm_que2.wpos - cur_pos61850; i++)
	{
		temp = iec61850_shm->shm_que2.slist[i + cur_pos61850];
	}
	cur_pos61850 += iec61850_shm->shm_que2.wpos - cur_pos61850;

}


void SendDataTo61850()
{

	//协调控制程序写命令区的示例代码如下：
	sem_wait(SHM_MUTEX2);
	//在此区间写数据

	sem_post(SHM_MUTEX2);
	sem_post(SHM_SEM2);
}

void *thread_61850_read(void *arg)
{

	while (1)
	{
		ReadDataFrom61850();
		usleep(10);
	}
}
void *thread_61850_write(void *arg)
{
	//	协调控制程序打开共享内存和信号量的示例代码如下：
	key_t key = ftok(IEC61850_IPC_PATH, IEC61850_IPC_KEY);
	int id = shmget(key, 0, 0);

	SHM_SEM1 = sem_open(SHM_SEM1_PATH, O_RDWR);

	SHM_SEM2 = sem_open(SHM_SEM2_PATH, O_RDWR);

	SHM_MUTEX1 = sem_open(SHM_MUTEX1_PATH, O_RDWR);

	SHM_MUTEX2 = sem_open(SHM_MUTEX2_PATH, O_RDWR);

	iec61850_shm = (iec61850_shm_packet_t *)shmat(id, NULL, 0);
	if (iec61850_shm == NULL)
	{
		printf("shmat error!\n");
		return NULL;
	}

	WritePCS();

	while (1)
	{
		ReadDataFrom61850(SHM_SEM1, SHM_MUTEX1);
		SendDataTo61850(SHM_SEM2, SHM_MUTEX2);
		usleep(2000); //延时2ms
	}
	return NULL;
}

void CreateThreads(void* para)
{
	pthread_t ThreadID;
	pthread_attr_t Thread_attr;
	memcpy((unsigned char*)pFrome61850,(unsigned char*)para,sizeof(PARA_61850));
	if (FAIL == CreateSettingThread(&ThreadID, &Thread_attr, (void *)thread_61850_write, NULL, 1, 1))
	{
		printf(" thread_61850_write CREATE ERR!\n");
		exit(1);
	}
	if (FAIL == CreateSettingThread(&ThreadID, &Thread_attr, (void *)thread_61850_read, NULL, 1, 1))
	{
		printf(" thread_61850_read CREATE ERR!\n");
		exit(1);
	}
	printf("thread_61850 CREATE success!\n");
}

void xxxxx(POINT_ADDR sAddr, void *data, int el_tag, int num)
{
	// 	int portID;
	// int devID;
	// int typeID;
	// int pointID;
	data_info_t data_temp;
	int i = 0;


			

	for (i = 0; i < num; i++)
	{
		data_temp.map.data = data_temp.buf;
		data_temp.map.el_tag = el_tag;
		data_temp.map.sAddr = sAddr;
		switch (el_tag)
		{
		case _BOOL:
			data_temp.map.data = (char*)data;
			data_temp.map.data_size = 1;
			break;
		case _INT:
		case _UINT:
		case _FLOAT:

			memcpy(data_temp.map.data, (char*)data, 4);
			data_temp.map.data_size = 4;
			break;

		default:
			return;
		}

	}
}